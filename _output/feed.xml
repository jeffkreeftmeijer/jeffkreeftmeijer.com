<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeff Kreeftmeijer</title>
  <link href="https://jeffkreeftmeijer.com/feed.xml" rel="self"/>
  <link href="https://jeffkreeftmeijer.com/"/>
  <updated>2017-09-19:00:00Z</updated>

  <id>http://jeffkreeftmeijer.com/</id>
  <author>
    <name>Jeff Kreeftmeijer</name>
  </author>

  <entry>
    <title type="html">Keeping open source projects maintainable</title>
    <link href="http://jeffkreeftmeijer.com/open-source-maintainability/"/>
    <id>http://jeffkreeftmeijer.com/open-source-maintainability/</id>
    <updated>2017-09-19:00:00Z</updated>
    <summary>If your open source project gains popularity, it will stay included in other people’s projects and workflows for years. It’s impossible to predict if you’ll have time to maintain your work in the future, but there are ways to minimize the amount of maintenance your project requires to remain useful.</summary>
    <content type="html">
      <![CDATA[
<a id="keeping-open-source-projects-maintainable"></a><h1>Keeping open source projects maintainable</h1>
<p>If your open source project gains popularity, it will stay included in other
people’s projects and workflows for years. It’s impossible to predict if you’ll
have time to maintain your work in the future, but there are ways to minimize
the amount of maintenance your project requires to remain useful.</p>
<a id="dont-add-or-merge-features-you-wont-use-yourself"></a><h2>Don’t add or merge features you won’t use yourself</h2>
<blockquote><p>It didn’t take long to add support for another database management
system into your background job library. You spent an evening getting it to
work, and fifteen minutes here and there in to fix some issues in the weeks
after releasing it. You don’t use that database yourself, but you have some
users who do, and it doesn’t take long to get it set up when somebody reports
a bug.</p>
<p>After a while, an issue comes up. Everything works for the database you use,
but it’s affecting the one you added later. You don’t have a lot of time or
motivation to fix it and setting up the database takes a while. The issue sits
there for a couple of weeks until somebody else sends a pull request. You
understand most of the fix, the code looks okay and you’re glad the bug is
solved, so you merge it in.</p>
<p>When another issue comes in months later, you have a bigger problem than
before. You still don’t have a lot of time to work on it, and you have code in
your project you didn’t completely understand back when you merged it in. Let
alone now.</p>
</blockquote>
<p>Instead of merging new features or implementing them yourself, allow for easy
extension. Consider separating your project’s database layer into an adapter
that’s easy to swap out for something else. If somebody needs your library to
run on MongoDB, for example, they can write an adapter themselves.</p>
<p>Don’t be afraid to tell contributors to maintain their fork instead of merging
their pull request. If a feature doesn’t help your own use case, it doesn’t
need to be in your project. This can be difficult if your users are
requesting a something you don’t need, but it’ll make your project easier to
maintain in the long run.</p>
<a id="drop-support-for-old-versions-of-your-dependencies"></a><h2>Drop support for old versions of your dependencies</h2>
<blockquote><p>You wrote a plug-in for your favorite editor that adds some useful
functionality. It’s a couple of lines, but wrapping it in a plug-in allows you
and others to install it using a plug-in manager.</p>
<p>A new version of the editor comes out, which adds some functionality that
makes your plug-in even more useful. You update it to take advantage of that
new feature and made sure not to break backward compatibility. It has a
version check that loads the original implementation when running in an older
version of the editor.</p>
<p>After a couple of years, you’d like to change the plug-in to add a new feature
or handle some use case better. When you open the code, you can’t find a way
to get this new feature working for the older versions of the editor.</p>
<p>You’re not sure if your changes will break anything, and you don’t have the
ancient editor version running on your machine. Although your project is
popular, you don’t know if anyone is still using the old version of the
editor.</p>
</blockquote>
<p>Whenever you start using a new version of a dependency, consider dropping
support for older versions and bumping your major version number. If your users
are tied to a previous version of your dependency, they should lock to an older
version of your project.  Dropping backward compatibility allows you to remove
conditional code that’s difficult to develop on.</p>
<p>Don’t backport new features. Since you have limited resources you want your
users to switch to new versions as quickly as possible, even if that means
they’ll have to spend time updating their dependencies.</p>
<a id="hand-over-projects-if-you-cant-help-anymore"></a><h2>Hand over projects if you can’t help anymore</h2>
<blockquote><p>You maintain an add-on for some kind of test framework, that’s specifically
suited for a problem you have. Since others have the same problem, your
project is used by hundreds of people. You haven’t implemented anything you
don’t use yourself, and you quickly drop support for old versions of the test
framework.</p>
<p>After a while, you start using another test framework on a daily basis. Maybe
because a new project at your job uses it, or your new situation doesn’t have
that problem your add-on fixed. You stop using your add-on.</p>
<p>Your project still provides value for its users, but you don’t have time to
reproduce issues you haven’t run into yourself. There’s a handful of people
excited about your project, so you usually receive a pull request when
something breaks.</p>
<p>After merging pull requests for a while, the code starts to lack structure
because there’s nobody actively maintaining the project. The code becomes
increasingly difficult to understand, and it’s becoming difficult to even
press the merge button without breaking the build.</p>
</blockquote>
<p>If you stop using your own project, you’re not fit to maintain it anymore. You
don’t have to do all the work, but you need to be among the first to know when
something breaks. If you don’t, you’re hurting the project more than you’re
helping.</p>
<p>Hand the project over to somebody that actively uses your project and knows the
code. If you can’t, open an issue in your tracker to announce you’re looking for
a new maintainer. Explain that you can’t help anymore and mention that you won’t
be answering issues or reviewing pull requests.</p>
      ]]>
    </content>
  </entry>

  <entry>
    <title type="html">Property-based testing in Elixir using PropEr</title>
    <link href="http://jeffkreeftmeijer.com/mix-proper/"/>
    <id>http://jeffkreeftmeijer.com/mix-proper</id>
    <updated>2017-08-22T00:00:00Z</updated>
    <summary>While reading Fred Hébert’s PropEr testing, on property-based testing in Erlang, I set out write PropEr tests in Elixir, and run them with a Mix task.</summary>
    <content type="html">
      <![CDATA[
<p>While reading <a href="http://ferd.ca" title="">Fred Hébert</a>’s <a href="http://propertesting.com" title="">PropEr testing</a>, on property-based testing in Erlang, I set out write <a href="http://proper.softlab.ntua.gr" title="">PropEr</a> tests in Elixir, and run them with a Mix task.<sup><a href="#fn:1" id="fnref:1" class="footnote" title="see footnote">1</a></sup></p>
<p><img src="https://jeffkreeftmeijer.com/mix-proper/mix_proper.png" alt="mix_proper running property-based tests in an Elixir project"/></p>
<h2>Writing PropEr tests in Elixir</h2>
<p>To explain writing PropEr tests (named “properties”) in Elixir, let’s take <a href="http://propertesting.com/book_stateless_properties.html#_writing_properties" title="">an example from PropEr testing</a>. A property of a function named <code class="inline">biggest/1</code> is that the returned value is equal to the biggest value in the passed list.</p>
<pre><code class="erlang"># test/prop_biggest.erl
-module(prop_biggest).
-include_lib(&quot;proper/include/proper.hrl&quot;).

prop_biggest() -&gt;
    ?FORALL(List, non_empty(list(integer())),              # ➊
        begin
            biggest(List) =:= lists:last(lists:sort(List)) # ➋
        end).</code></pre>
<ol>
<li><p><code class="inline">?FORALL</code> is a macro around <code class="inline">proper:forall/2</code>.<sup><a href="#fn:2" id="fnref:2" class="footnote" title="see footnote">2</a></sup> It takes a variable name, a generator, and a property. In this case, the generator returns a random, non-empty list of integers and puts it in the <code class="inline">List</code> variable for every run.</p>
</li>
<li><p>The property itself is a function that uses the random variable to assert the result from <code class="inline">biggest/1</code> matches the biggest value in the list.</p>
</li>
</ol>
<p>Converting it to Elixir, this property looks a bit different.</p>
<pre><code class="elixir"># test/biggest_prop.exs
defmodule BiggestProp do
  # ➊
  import :proper
  import :proper_types

  def prop_biggest do
    forall(non_empty(list(integer())), fn(list) -&gt;    # ➋
      biggest(list) == list |&gt; Enum.sort |&gt; List.last # ➌
    end)
  end

  # ...
end</code></pre>
<ol>
<li>The <code class="inline">:proper</code> and <code class="inline">:proper_types</code> modules are imported manually instead of including the <code class="inline">proper.hrl</code> header file, which is a mostly <a href="https://github.com/manopapad/proper/blob/master/include/proper.hrl" title="">a list of imports</a> itself.
</li>
<li>Elixir <a href="https://groups.google.com/forum/#!topic/elixir-lang-talk/VbGTz7rKebM" title="">doesn’t support Erlang’s macros</a>, so <code class="inline">:proper.forall/2</code> is called directly.
</li>
<li>Although Erlang’s <code class="inline">lists</code> module would work, <code class="inline">Enum.sort/1</code> and <code class="inline">List.last/1</code> are used as trusted functions to test the implementation.
</li>
</ol>
<p>With a <a href="https://github.com/jeffkreeftmeijer/mix_proper_example/blob/a09d6ac1bc800ae3f77a105c76f8db44d9b8d5ce/test/biggest_prop.exs#L19-L27" title="">working implementation</a>, and <a href="https://hex.pm/packages/proper" title="">:proper</a> included in the project’s dependencies, the property can be run in IEx by requiring the test file manually and running the property through <code class="inline">:proper.quickcheck/1</code>.</p>
<pre><code class="">$ iex -S mix
iex(1)&gt; Kernel.ParallelRequire.files([&quot;test/biggest_prop.exs&quot;])
[BiggestProp]
iex(2)&gt; :proper.quickcheck(BiggestProp.prop_biggest())
....................................................................................................
OK: Passed 100 test(s).
true</code></pre>
<h2>rebar3_proper and mix_proper</h2>
<p>Although that worked, it would be nice to have a command to quickly run all tests in a Mix project. For Erlang, there’s a library named <a href="https://github.com/ferd/rebar3_proper" title="">rebar3_proper</a> that does just that by adding the <code class="inline">rebar3 proper</code> command.</p>
<pre><code class="">$ rebar3 proper
===&gt; Testing prop_biggest:prop_biggest()
....................................................................................................
OK: Passed 100 test(s).
===&gt;
1/1 properties passed</code></pre>
<p>rebar3_proper runs tests by finding functions and modules with names prefixed with “prop_” and running them through <code class="inline">proper:quickcheck/1</code>. That would work in Elixir by adding a Mix task that uses the same approach.<sup><a href="#fn:3" id="fnref:3" class="footnote" title="see footnote">3</a></sup></p>
<pre><code class="elixir">defmodule Mix.Tasks.Proper do
  use Mix.Task

  def run([]) do
    &quot;test/**/*_prop.exs&quot;
    |&gt; Path.wildcard
    |&gt; Kernel.ParallelRequire.files # =&gt; [BiggestProp]
    # ...
  end

  # ...
end</code></pre>
<p>Using “test/**/*_prop.exs” as a wildcard pattern, the paths for all property-based testing files in the test directory are found. Being .exs files, they are not compiled, so they need to be required manually when they’re needed. <a href="https://github.com/elixir-lang/elixir/blob/df7e0ca55cd03e3d46f426c7cd02fd25dcf2df87/lib/mix/lib/mix/compilers/test.ex#L50" title="">Mix’s own test task uses <code class="inline">Kernel.ParallelRequire.files/1-2</code></a>, which takes a list of filenames, includes the modules in the files and returns the names of the newly included modules.</p>
<pre><code class="elixir">defmodule Mix.Tasks.Proper do
  use Mix.Task

  def run([]) do
    &quot;test/**/*_prop.exs&quot;
    |&gt; Path.wildcard
    |&gt; Kernel.ParallelRequire.files
    |&gt; Enum.each(fn(module) -&gt;
      module.__info__(:functions)
      |&gt; Enum.filter(&amp;property?/1)
      |&gt; Enum.map(fn({name, 0}) -&gt;
        :proper.quickcheck(apply(module, name, []))
      end)
    end)
  end

  # ...
end</code></pre>
<p>Using the list of included modules, their property functions are found using the <code class="inline">__info__/1</code> function. Functions without the proper name or an arity other than 0 get <a href="https://github.com/jeffkreeftmeijer/mix_proper/blob/fda1e4b19c6aabdf856b7d4948102409e0a5c9fc/lib/mix/tasks/proper.ex#L30-L35" title="">filtered out</a>. The remaining functions in the list are called using <code class="inline">:erlang.apply/3</code>, and their results are passed to <code class="inline">:proper.quickcheck/1</code>, which runs the tests.</p>
<pre><code class="">$ mix proper
....................................................................................................
OK: Passed 100 test(s).</code></pre>
<p>That’s it. The proper Mix task finds property-based test files, includes them, and runs each of the properties in those files through PropEr. The code above is the basis of <a href="https://github.com/jeffkreeftmeijer/mix_proper" title="">mix_proper</a>, which can be used in your Elixir project by <a href="https://github.com/jeffkreeftmeijer/mix_proper_example/blob/master/mix.exs#L24" title="">adding it as a dependency</a>.<sup><a href="#fn:4" id="fnref:4" class="footnote" title="see footnote">4</a></sup></p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1"><p>Besides running PropEr, there are more ways to do property-based testing with Elixir.</p>
<p><a href="https://github.com/whatyouhide/stream_data" title="">StreamData</a> and <a href="https://github.com/pragdave/quixir" title="">Quixir</a> are both pure-Elixir libraries. StreamData is a candidate to be included in Elixir itself. If you want to get into property-based testing, one of these is probably your best bet. <a href="https://github.com/parroty/excheck" title="">ExCheck</a> is a wrapper around <a href="https://github.com/krestenkrab/triq" title="">triq</a>, while <a href="https://github.com/alfert/propcheck" title="">PropCheck</a> wraps PropEr. All of them use ExUnit to run their tests.</p>
<p>However, I was curious to see if I could get it to work without having to wrap a lot of PropEr’s functions by just importing its modules in Elixir and running its functions directly while learning some things about Erlang along the way.&nbsp;<a href="#fnref:1" title="return to article" class="reversefootnote">&#x21A9;</a></p>
</li>
<li id="fn:2"><p>Since <code class="inline">?FORALL</code> is a macro around <code class="inline">proper:forall/2</code>, this example can also be written without it, revealing the function call underneath.</p>
<pre><code class=""># test/prop_biggest.erl
-module(prop_biggest).
-include_lib(&quot;proper/include/proper.hrl&quot;).

prop_biggest() -&gt;
    proper:forall(non_empty(list(integer())), fun(List) -&gt;
        biggest(List) =:= lists:last(lists:sort(List))
    end).</code></pre>
<p><a href="#fnref:2" title="return to article" class="reversefootnote">&#x21A9;</a></p>
</li>
<li id="fn:3"><p>Instead of <em>prefixing</em> the names for modules with property-based tests with “”Prop” (like “PropBiggest”), I chose to add it as a suffix. By adding “Prop” to the end, the module names are in line with ExUnit’s, which suffixes its test case module names with “Test” (like “BiggestTest”, for example).</p>
<p>The names for the properties themselves <em>are</em> prefixed with “prop_”, like in rebar3_proper, for now. I could do away with function name matching and use a macro to use for defining tests (like StreamData does, for example), but I like not having to import anything but PropEr’s modules.&nbsp;<a href="#fnref:3" title="return to article" class="reversefootnote">&#x21A9;</a></p>
</li>
<li id="fn:4"><p>mix_proper is still a proof of concept. Although running tests works, you could run into some problems with PropEr’s generators in Elixir. If you run into one, please don’t hesitate to open an <a href="https://github.com/jeffkreeftmeijer/mix_proper/issues" title="">issue</a>.&nbsp;<a href="#fnref:4" title="return to article" class="reversefootnote">&#x21A9;</a></p>
</li>
</ol>

</div>
      ]]>
    </content>
  </entry>
</feed>
